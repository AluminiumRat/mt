#version 450

#include "lib/color.inl"
#include "posteffects/bloom.inl"

#define GROUP_SIZE 1024

layout (local_size_x = GROUP_SIZE,
        local_size_y = 1,
        local_size_z = 1) in;

//  Здесь даунсэмплим исходное изображение в 4 раза
vec3 getSourceColor()
{
  vec2 sourceStartTexel = gl_GlobalInvocationID.xy * 4 + vec2(0.5f, 0.5f);
  vec2 sourceStartUV = sourceStartTexel * params.invSourceSize;
  vec2 step = params.invSourceSize;

  vec3 maxColor = vec3(0);
  for(float i = 0; i < 4; i++)
  {
    for(float j = 0; j < 4; j++)
    {
      vec2 uvCoord = sourceStartUV + step * vec2(i, j);
      vec3 sourceColor = textureLod(sampler2D(sourceImage, linearSampler),
                                    uvCoord,
                                    0).rgb;
      maxColor = max(maxColor,sourceColor);
    }
  }
  return maxColor;
}

//  shared memory, предназначенная для обмена данными между пикселями
//  обрабатываемой строки. Сюда скидываем промежуточные значения цветов
shared vec3 textels[GROUP_SIZE];

void main()
{
  ivec2 pixelCoord = ivec2(gl_GlobalInvocationID.xy);
  if(pixelCoord.x >= params.targetSize.x) return;

  //  Берем цвет из исходной картинки
  vec3 myColor = getSourceColor();

  //  Обрезаем по яркости, чтобы слабые пиксели не размазывались
  float luminance = colorToLuminance(myColor);
  myColor *= smoothstep(params.threshold * 0.9f,
                        params.threshold * 1.1f,
                        luminance);

  //  На каком расстоянии находится сосед, с которым смешиваем
  //  цвета. Разлет будет увеличиваться на каждом шаге
  int neighborShift = 1;

  for(int step = 0; step < BLOOR_STEPS; step++)
  {
    //  Сохраняем текущий цвет пикселя в общей памяти, чтобы соседи могли
    //  смешать с ним свои цветаю
    textels[pixelCoord.x] = myColor * NEIGHBOR_WEIGHT;

    //  Ждем, когда соседи тоже сохранят свой цвет в общей памяти
    barrier();

    //  Считываем цвета соседей и смешиваем их со своим
    //  Координаты текселей, с которыми будем смешивать текущий
    int leftNeighbor = max(pixelCoord.x - neighborShift, 0);
    int rightNeighbor = min(pixelCoord.x + neighborShift,
                            params.targetSize.x - 1);
    myColor = myColor * CENTER_WEIGHT +
                          textels[leftNeighbor] + textels[rightNeighbor];
    neighborShift *= 2;
  }

  imageStore(targetImage, pixelCoord, vec4(myColor, 1.0f));
}